import json
import urllib
import urlparse
import requests
import traceback
import pyramid
import sys
import time
import os
import re
import md5
import logging
import filelock
from pyramid.httpexceptions import HTTPFound
from pyramid.view import view_config
from pyramid.response import FileResponse
from requests_oauthlib import OAuth1

from pyramid.renderers import render

from lti.config import configure


log = logging.getLogger(__name__)


files_path = './lti/static/pdfjs/viewer/web'


def lti_server(settings):
    lti_server_port = settings['lti_server_port']
    lti_server_scheme = settings['lti_server_scheme']
    lti_server_host = settings['lti_server_host']

    if lti_server_port is None:
        return '%s://%s' % (lti_server_scheme, lti_server_host)
    else:
        return '%s://%s:%s' % (lti_server_scheme, lti_server_host, lti_server_port)

def lti_setup_url(settings):
    return '%s/lti_setup' % lti_server(settings)


def lti_export_url(settings):
    return '%s/lti_export' % lti_server(settings)


# canvas params
CUSTOM_CANVAS_COURSE_ID = 'custom_canvas_course_id'
CUSTOM_CANVAS_USER_ID = 'custom_canvas_user_id'
CUSTOM_CANVAS_ASSIGNMENT_ID = 'custom_canvas_assignment_id'
OAUTH_CONSUMER_KEY = 'oauth_consumer_key'
EXT_CONTENT_RETURN_TYPES = 'ext_content_return_types'
EXT_CONTENT_RETURN_URL = 'ext_content_return_url'
LIS_OUTCOME_SERVICE_URL = 'lis_outcome_service_url'
LIS_RESULT_SOURCEDID = 'lis_result_sourcedid'

# our params
EXPORT_URL = 'export_url'
ASSIGNMENT_TYPE = 'assignment_type'
ASSIGNMENT_NAME = 'assignment_name'
ASSIGNMENT_VALUE = 'assignment_value'


NO_PDF_FINGERPRINT = 'no pdf fingerprint'


class AuthData(): 
    """
    A simple config db, with records like so:

    "93820000000000002": {        # situation 1 in the install doc: admin provided key/secret
      "canvas_server_host": "hypothesis.instructure.com", 
      "canvas_server_port": null, 
      "canvas_server_scheme": "https", 
      "lti_refresh_token": "9382~yRo ... Rlid9UXLhxfvwkWDnj",        # this was written back after oauth
      "lti_token": "9382~IAbeGEFScV  ... IIMaEdK3dXlm2d9cjozd",      # this was written back after oauth
      "secret": "tJzcNSZadqlHTCW6ow  ... wodX3dfeuIokkLMjrQJqw3Y2"   # from the canvas dev key/secret record
   }, 
     "jaimejordan": {       # situation 2: teacher created a token, we installed it and created the key/secret
      "canvas_server_host": "hypothesis.instructure.com", 
      "canvas_server_port": null, 
      "canvas_server_scheme": "https", 
      "lti_refresh_token": null,                      # unused because token hardcoded in this case
      "lti_token": "9382~IAbeGEFSc ... VGmtBU",       # token generated by teacher (canvas "approved integration")
      "secret": "jaimejordan"  
  }, 

    """
    def __init__(self):
        self.name = 'canvas-auth.json'
        self.auth_data = {}
        self.load()

    def set_tokens(self, oauth_consumer_key, lti_token, lti_refresh_token):
        assert (self.auth_data.has_key(oauth_consumer_key))
        lock = filelock.FileLock("authdata.lock")
        with lock.acquire(timeout = 1):
            self.auth_data[oauth_consumer_key]['lti_token'] = lti_token
            self.auth_data[oauth_consumer_key]['lti_refresh_token'] = lti_refresh_token
            self.save()

    def get_lti_token(self, oauth_consumer_key):
        return self.auth_data[oauth_consumer_key]['lti_token']

    def get_lti_refresh_token(self, oauth_consumer_key):
        return self.auth_data[oauth_consumer_key]['lti_refresh_token']

    def get_lti_secret(self, oauth_consumer_key):
        return self.auth_data[oauth_consumer_key]['secret']

    def get_canvas_server_scheme(self, oauth_consumer_key):
        return self.auth_data[oauth_consumer_key]['canvas_server_scheme']

    def get_canvas_server_host(self, oauth_consumer_key):
        return self.auth_data[oauth_consumer_key]['canvas_server_host']

    def get_canvas_server_port(self, oauth_consumer_key):
        return self.auth_data[oauth_consumer_key]['canvas_server_port']

    def get_canvas_server(self, oauth_consumer_key):
        canvas_server_scheme = self.get_canvas_server_scheme(oauth_consumer_key)
        canvas_server_host = self.get_canvas_server_host(oauth_consumer_key)
        canvas_server_port = self.get_canvas_server_port(oauth_consumer_key)
        canvas_server = None
        if canvas_server_port is None:
            canvas_server = '%s://%s' % (canvas_server_scheme, canvas_server_host)
        else:
            canvas_server = '%s://%s:%s' % (canvas_server_scheme, canvas_server_host, canvas_server_port)
        return canvas_server

    def load(self):
        f = open(self.name)
        self.auth_data = json.loads(f.read())
        for key in self.auth_data.keys():
            log.info( 'key: %s' % key)
        f.close()

    def save(self):
        f = open(self.name, 'wb')
        j = json.dumps(self.auth_data, indent=2, sort_keys=True)
        f.write(j)
        f.close()  

auth_data = AuthData()

def get_pdf_fingerprint(hash):
    """
    We need the fingerprint to query for annotations on the submission page.

    NB: PDFJS always reports fingerpints with lowercase letters and that's required for a Hypothesis lookup,
    even when the fingerprint found in the doc uses uppercase!
    """
    f = open('%s/%s.pdf' % (files_path, hash), 'rb')
    s = f.read()
    m = re.findall('ID\s*\[\s*<(\w+)>',s)
    f.close()
    if len(m) > 0:
        return m[0].lower()
    else:
        return NO_PDF_FINGERPRINT

def render_submission_template(settings, oauth_consumer_key=None, lis_outcome_service_url=None, lis_result_sourcedid=None, doc_uri=None):
    """
    For the Find interaction we need to inject these values into the JS we generate.
    """
    return render('lti:templates/submission_form.html.jinja2', dict(
        oauth_consumer_key=oauth_consumer_key,
        lis_outcome_service_url=lis_outcome_service_url,
        lis_result_sourcedid=lis_result_sourcedid,
        doc_uri=doc_uri,
        lti_server=lti_server(settings),
    ))

def unpack_state(state):
    dict = json.loads(urllib.unquote(state))
    return dict

def pack_state(dict):
    state = urllib.quote(json.dumps(dict))
    return state

def token_init(request, state=None):
    """ We don't have a Canvas API token yet. Ask Canvas for an authorization code to begin the token-getting OAuth flow """
    try:
        dict = unpack_state(state)
        log.info( 'token_init: state: %s' % dict )
        oauth_consumer_key = dict[OAUTH_CONSUMER_KEY]
        canvas_server = auth_data.get_canvas_server(oauth_consumer_key)
        token_redirect_uri = '%s/login/oauth2/auth?client_id=%s&response_type=code&redirect_uri=%s/token_callback&state=%s' % (canvas_server, oauth_consumer_key, lti_server(request.registry.settings), state)
        ret = HTTPFound(location=token_redirect_uri)
        log.info( 'token_init ' + token_redirect_uri )
        return ret
    except:
        response = traceback.print_exc()
        log.error(response)
        return simple_response(response)

def refresh_init(request, state=None):
    """ Our Canvas API token expired. Ask Canvas for an authorization code to begin the token-refreshing OAuth flow """
    try:
        dict = unpack_state(state)
        log.info( 'refresh_init: state: %s' % dict )
        oauth_consumer_key = dict[OAUTH_CONSUMER_KEY]
        canvas_server = auth_data.get_canvas_server(oauth_consumer_key)
        token_redirect_uri = '%s/login/oauth2/auth?client_id=%s&response_type=code&redirect_uri=%s/refresh_callback&state=%s' % (canvas_server, oauth_consumer_key, lti_server(request.registry.settings), state)
        ret = HTTPFound(location=token_redirect_uri)
        return ret
    except:
        response = traceback.print_exc()
        log.error(response)
        return simple_response(response)

@view_config( route_name='token_callback' )
def token_callback(request):
    return oauth_callback(request, type='token')

@view_config( route_name='refresh_callback' )
def refresh_callback(request):
    return oauth_callback(request, type='refresh')

def oauth_callback(request, type=None):
    """ Canvas called back with an authorization code. Use it to get or refresh an API token """
    try:
        log.info ( 'oauth_callback: %s' % request.query_string )
        q = urlparse.parse_qs(request.query_string)
        code = q['code'][0]
        state = q['state'][0]
        dict = unpack_state(state)
        log.info ( 'oauth_callback: %s' % state)

        course = dict[CUSTOM_CANVAS_COURSE_ID]
        user = dict[CUSTOM_CANVAS_USER_ID]
        oauth_consumer_key = dict[OAUTH_CONSUMER_KEY]
        ext_content_return_url = dict[EXT_CONTENT_RETURN_URL]
        lis_outcome_service_url = dict[LIS_OUTCOME_SERVICE_URL]
        lis_result_sourcedid = dict[LIS_RESULT_SOURCEDID]

        assignment_type = dict[ASSIGNMENT_TYPE]
        assignment_name = dict[ASSIGNMENT_NAME]
        assignment_value = dict[ASSIGNMENT_VALUE]

        canvas_client_secret = auth_data.get_lti_secret(oauth_consumer_key)
        lti_refresh_token = auth_data.get_lti_refresh_token(oauth_consumer_key)
        canvas_server = auth_data.get_canvas_server(oauth_consumer_key)
        url = '%s/login/oauth2/token' % canvas_server
        grant_type = 'authorization_code' if type == 'token' else 'refresh_token'
        params = { 
                'grant_type': grant_type,
                'client_id': oauth_consumer_key,
                'client_secret': canvas_client_secret,
                'redirect_uri': '%s/token_init' % lti_server(request.registry.settings) # this uri must match the uri in Developer Keys but is not called from
                }                                                                       # canvas. rather it calls token_callback or refresh callback
        if grant_type == 'authorization_code': 
            params['code'] = code
        else:
            params['refresh_token'] = lti_refresh_token
        r = requests.post(url, params)
        dict = r.json()
        lti_token = dict['access_token']
        if dict.has_key('refresh_token'): # does it ever not?
            lti_refresh_token = dict['refresh_token']
        auth_data.set_tokens(oauth_consumer_key, lti_token, lti_refresh_token)
        redirect = lti_setup_url(request.registry.settings) + '?%s=%s&%s=%s&%s=%s&%s=%s&%s=%s&%s=%s&%s=%s' % (
            CUSTOM_CANVAS_COURSE_ID, course, 
            CUSTOM_CANVAS_USER_ID, user, 
            OAUTH_CONSUMER_KEY, oauth_consumer_key, 
            EXT_CONTENT_RETURN_URL, ext_content_return_url,
            ASSIGNMENT_TYPE, assignment_type,
            ASSIGNMENT_NAME, assignment_name,
            ASSIGNMENT_VALUE, assignment_value
            )
        return HTTPFound(location=redirect)
    except:
        response = traceback.print_exc()
        log.error(response)
        return simple_response(response)

def bare_response(text):
    r = Response(text.encode('utf-8'))
    r.headers.update({
        'Access-Control-Allow-Origin': '*'
        })
    r.content_type = 'text/plain'
    return r

def simple_response(exc_str):
    template = """
 <html>
 <head> <style> body { font-family:verdana; margin:.5in; } </style> </head>
 <body>%s</body>
 </html>"""
    html = template % exc_str
    r = Response(html.encode('utf-8'))
    r.content_type = 'text/html'
    return r

def page_response(html):
    r = Response(html.encode('utf-8'))
    r.headers.update({
        'Access-Control-Allow-Origin': '*'
        })
    r.content_type = 'text/html'
    return r

def serve_file(path=None, file=None, request=None, content_type=None):
    response = FileResponse('%s/%s' % (path, file),
                            request=request,
                            content_type=content_type)
    return response


@view_config(route_name='config_xml',
             renderer='config.xml.jinja2',
             request_method='GET')
def config_xml(request):
    request.response.content_type = 'text/xml'
    return {
        'launch_url': lti_setup_url(request.registry.settings),
        'resource_selection_url': lti_setup_url(request.registry.settings),
    }


@view_config( route_name='about' )
def about(request):
    return serve_file('.', 'about.html', request, 'text/html')

def pdf_response(settings, oauth_consumer_key=None, lis_outcome_service_url=None, lis_result_sourcedid=None, name=None, hash=None, doc_uri=None):
    log.info( 'pdf_response: %s, %s, %s, %s, %s, %s' % (oauth_consumer_key, lis_outcome_service_url, lis_result_sourcedid, name, hash, doc_uri) )
    submit_html = ''
    if lis_result_sourcedid is not None:  # it is a student
        submit_html = render_submission_template(settings, oauth_consumer_key, lis_outcome_service_url, lis_result_sourcedid, doc_uri)
    html = render('lti:templates/pdf_assignment.html.jinja2', dict(
        name=name,
        submit_html=submit_html,
        hash=hash,
    ))
    r = Response(html.encode('utf-8'))
    r.content_type = 'text/html'
    return r

def capture_post_data(request):
    ret = {}
    for key in [
            OAUTH_CONSUMER_KEY,
            CUSTOM_CANVAS_USER_ID,
            CUSTOM_CANVAS_COURSE_ID,
            CUSTOM_CANVAS_ASSIGNMENT_ID,
            EXT_CONTENT_RETURN_TYPES,
            EXT_CONTENT_RETURN_URL,
            LIS_OUTCOME_SERVICE_URL,
            LIS_RESULT_SOURCEDID
            ]:
        if key in request.POST.keys():
            ret[key] = request.POST[key]
        else:
            ret[key] = None
    return ret

def get_post_or_query_param(request, key):
    value = get_query_param(request, key)
    if value is not None:
        ret = value
    else:
        value = get_post_param(request, key)
        ret = value
    if ret is None:
        if key == CUSTOM_CANVAS_COURSE_ID:
            log.warning ( 'is privacy set to public in courses/COURSE_NUM/settings/configurations?' )
    return ret

def get_query_param(request, key):
    q = urlparse.parse_qs(request.query_string)
    if q.has_key(key):
      return q[key][0]
    else:
      return None

def get_post_param(request, key):
    post_data = capture_post_data(request)
    if post_data.has_key(key):
        return post_data[key]
    else:
        return None

@view_config( route_name='lti_setup' )
def lti_setup(request):
    """
    LTI-launched from a Canvas assignment's Find interaction to present choice of doc (PDF or URL) to annotate.
  
    LTI-launched again when the Canvas assignment opens.
  
    In those two cases we have LTI params in the HTTP POST -- if we have a Canvas API token.

    If there is no token, or the token is expired, called instead by way of OAuth redirect. 
    In that case we expect params in the query string.
    """
    log.info ( 'lti_setup: query: %s' % request.query_string )
    log.info ( 'lti_setup: post: %s' % request.POST )
    dict = capture_post_data(request)

    oauth_consumer_key = get_post_or_query_param(request, OAUTH_CONSUMER_KEY)
    if oauth_consumer_key is None:
        log.error( 'oauth_consumer_key cannot be None %s' % request.POST )
    oauth_consumer_key = oauth_consumer_key.strip()
    lis_outcome_service_url = get_post_or_query_param(request, LIS_OUTCOME_SERVICE_URL)
    lis_result_sourcedid = get_post_or_query_param(request, LIS_RESULT_SOURCEDID)

    course = get_post_or_query_param(request, CUSTOM_CANVAS_COURSE_ID)
    if course is None:
        log.error ( 'course cannot be None' )
        return simple_response('No course number. Was Privacy set to Public for this installation of the Hypothesis LTI app? If not please do so (or ask someone who can to do so).')
    
    dict[ASSIGNMENT_TYPE] = get_post_or_query_param(request, ASSIGNMENT_TYPE)
    dict[ASSIGNMENT_NAME] = get_post_or_query_param(request, ASSIGNMENT_NAME)
    dict[ASSIGNMENT_VALUE] = get_post_or_query_param(request, ASSIGNMENT_VALUE)

    log.info ( 'lti_setup: dict: %s' % dict )

    try:
        lti_token = auth_data.get_lti_token(oauth_consumer_key)
    except:
        response = "We don't have the Consumer Key %s in our database yet." % oauth_consumer_key
        log.error ( response )
        log.error ( traceback.print_exc() )
        return simple_response(response)

    if lti_token is None:
        log.info ( 'lti_setup: getting token' )
        return token_init(request, pack_state(dict))

    sess = requests.Session()  # ensure we have a token before calling lti_pdf or lti_web
    canvas_server = auth_data.get_canvas_server(oauth_consumer_key)
    log.info ( 'canvas_server: %s' % canvas_server )
    url = '%s/api/v1/courses/%s/files?per_page=100' % (canvas_server, course)
    r = sess.get(url=url, headers={'Authorization':'Bearer %s' % lti_token })
    if r.status_code == 401:
      log.info ( 'lti_setup: refreshing token' )
      return refresh_init(request, pack_state(dict))
    files = r.json()
    while ('next' in r.links):
        url = r.links['next']['url']
        r = sess.get(url=url, headers={'Authorization':'Bearer %s' % lti_token })
        files = files + r.json()
    log.info ('files: %s' % len(files))

    #return HTTPFound(location='http://h.jonudell.info:3000/courses/2/external_content/success/external_tool_dialog?return_type=lti_launch_url&url=http%3A%2F%2F98.234.245.185%3A8000%2Flti_setup%3FCUSTOM_CANVAS_COURSE_ID%3D2%26type%3Dpdf%26name%3Dfilename%26value%3D9')
    
    assignment_type = dict[ASSIGNMENT_TYPE]
    assignment_name = dict[ASSIGNMENT_NAME]
    assignment_value = dict[ASSIGNMENT_VALUE]

    if assignment_type == 'pdf':
        return lti_pdf(request, oauth_consumer_key=oauth_consumer_key, lis_outcome_service_url=lis_outcome_service_url, lis_result_sourcedid=lis_result_sourcedid, course=course, name=assignment_name, value=assignment_value)

    if assignment_type == 'web':
        return lti_web(request, oauth_consumer_key=oauth_consumer_key, lis_outcome_service_url=lis_outcome_service_url, lis_result_sourcedid=lis_result_sourcedid, course=course, name=assignment_name, value=assignment_value)

    return_url = get_post_or_query_param(request, EXT_CONTENT_RETURN_URL)
    if return_url is None: # this is an oauth redirect so get what we sent ourselves
        return_url = get_post_or_query_param(request, 'return_url')

    log.info ( 'return_url: %s' % return_url )

    launch_url_template = '%s/lti_setup?assignment_type=__TYPE__&assignment_name=__NAME__&assignment_value=__VALUE__&return_url=__RETURN_URL__' % lti_server(request.registry.settings)

    log.info ( 'key %s, course %s, token %s' % (oauth_consumer_key, course, lti_token) )

    """ this is the ux for choosing which pdf or web page to annotate """
    template = """
<html><head> 
<style> 
body { font-family:verdana; margin:.5in; font-size:smaller } 
p { font-weight: bold }
ul { list-style-type: none; padding: 0 }
li { margin: 4px 0 }
#pdf_select, #web_select { display: none }
</style> 
<script>
var checked_boxes;

function getRVBN(rName) {
    var radioButtons = document.getElementsByName(rName);
    for (var i = 0; i < radioButtons.length; i++) {
        if (radioButtons[i].checked)
            return radioButtons[i];
    }
    return '';
}

function show() {
  var type = getRVBN('format').value;
  if ( type=='pdf' ) {
    document.getElementById('pdf_select').style.display = 'block';
    document.getElementById('web_select').style.display = 'none';
    }
  if ( type=='web' ) {
    document.getElementById('web_select').style.display = 'block';
    document.getElementById('pdf_select').style.display = 'none';
    }
  }

function go() {
    var return_url = '%s';
    var launch_url = '%s';
    var redirect_url;
    var type = getRVBN('format').value;

    if ( type == 'pdf' ) {
      var pdf_choice = getRVBN('pdf_choice');
      launch_url = launch_url.replace('__TYPE__',  'pdf');
      launch_url = launch_url.replace('__NAME__',  encodeURIComponent(pdf_choice.value));
      launch_url = launch_url.replace('__VALUE__', pdf_choice.id);
      redirect_url = return_url + '?return_type=lti_launch_url&url=' + encodeURIComponent(launch_url);
      }

    if ( type == 'web' ) {
      var url = document.getElementById('web_url').value;
      launch_url = launch_url.replace('__TYPE__',  'web');
      launch_url = launch_url.replace('__NAME__',  url);
      launch_url = launch_url.replace('__VALUE__', url);
      launch_url = launch_url.replace('__RETURN_URL__', return_url);
      redirect_url = return_url + '?return_type=lti_launch_url&url=' + encodeURIComponent(launch_url);
      }

  window.location.href = redirect_url;
  }
</script>
</head>
<body>
<p>
I want students to annotate:
<div>
<input onchange="javascript:show()" id="pdf_choice" type="radio" name="format" value="pdf"> A PDF file
<input onchange="javascript:show()" id="web_choice" type="radio" name="format" value="web"> A web page
</div>
</p>

<div id="pdf_select">
<p<Select a PDF from the Canvas Files in this course</p>
%s 
</div>
<div id="web_select">
<p>Enter a URL</p>
<input size="80" id="web_url" onchange="javascript:go()"></input>
</p>
</div>

</body>
</html>
""" 
    pdf_choices = ''
    if len(files) > 0:
        pdf_choices += '<ul>'
        for file in files:
            id = str(file['id'])
            name = file['display_name']
            if not name.lower().endswith('.pdf'):
                continue
            pdf_choices += '<li><input type="radio" name="pdf_choice" onclick="javascript:go()" value="%s" id="%s">%s</li>' % (name, id, name) 
        pdf_choices += '</ul>'
   
    html = template % (
        return_url,
        launch_url_template,
        pdf_choices
        )
    r = Response(html.encode('utf-8'))
    r.content_type = 'text/html'
    return r

def exists_pdf(hash):
    return os.path.isfile('%s/%s.pdf' % (files_path, hash))

def exists_html(hash):
    return os.path.isfile('%s/%s.html' % (files_path, hash))

def lti_pdf(request, oauth_consumer_key=None, lis_outcome_service_url=None, lis_result_sourcedid=None, course=None, name=None, value=None):
    """ 
    Called from lti_setup if it was called from a pdf assignment. 

    We expect to know at least the oauth_consume_key, course number, name of the PDF, 
    and value of the PDF (its number as known to the Canvas API)

    If we are called in a student context we also expect the lis* params needed for the submission URL.

    Download the PDF to a timestamp-based name in the PDFJS subtree, and call pdf_response to 
    return a page that serves it back in an iframe.
    """
    log.info ( 'lti_pdf: query: %s' % request.query_string )
    log.info ( 'lti_pdf: post: %s' % request.POST )
    post_data = capture_post_data(request)
    if oauth_consumer_key is None:
        oauth_consumer_key = get_post_or_query_param(request, OAUTH_CONSUMER_KEY)
    file_id = value
    try:
        lti_token = auth_data.get_lti_token(oauth_consumer_key)
    except:
        return simple_response("We don't have the Consumer Key %s in our database yet." % oauth_consumer_key)
    canvas_server = auth_data.get_canvas_server(oauth_consumer_key)
    url = '%s/api/v1/courses/%s/files/%s' % (canvas_server, course, file_id)
    m = md5.new()
    m.update('%s/%s/%s' % ( canvas_server, course, file_id ))
    hash = m.hexdigest()
    log.info( 'server %s, course %s, file_id %s, hash %s' % ( canvas_server, course, file_id, hash ))
    if exists_pdf(hash) is False:
        sess = requests.Session()
        r = sess.get(url=url, headers={'Authorization':'Bearer %s' % lti_token})
        if r.status_code == 401:
          log.info( 'lti_pdf: refreshing token' )
          return refresh_init(request, 'pdf:' + urllib.quote(json.dumps(post_data)))
        if r.status_code == 200:
            j = r.json()
            log.info( j )
            url = j['url']
            log.info( url )
            urllib.urlretrieve(url, hash)
            os.rename(hash, '%s/%s.pdf' % (files_path, hash))
        else:
            log.error('%s retrieving %s, %s, %s' % (r.status_code, canvas_server, course, file_id))
    fingerprint = get_pdf_fingerprint(hash)
    if fingerprint == NO_PDF_FINGERPRINT:
        pdf_uri = '%s/viewer/web/%s.pdf' % ( lti_server(request.registry.settings), hash )
    else:
        pdf_uri = 'urn:x-pdf:%s' % fingerprint
    return pdf_response(request.registry.settings, oauth_consumer_key=oauth_consumer_key, lis_outcome_service_url=lis_outcome_service_url, lis_result_sourcedid=lis_result_sourcedid, name=name, hash=hash, doc_uri=pdf_uri)

def web_response(settings, oauth_consumer_key=None, course=None, lis_outcome_service_url=None, lis_result_sourcedid=None, name=None, value=None, user=None):
    """
    Our app was called from an assignment to annotate a web page.

    Run it through via, and save it as a timestamped name in the PDFJS subtree.

    Neuter the JS return so the page will run in a Canvas iframe.

    Instantiate the submission template so the student can submit the assignment.

    Serve a page that wraps the (lightly) transformed via output in an iframe.
    """
    url = value
    canvas_server = auth_data.get_canvas_server(oauth_consumer_key)
    m = md5.new()
    m.update('%s/%s/%s' % ( canvas_server, course, url ))
    hash = m.hexdigest()
    log.info( 'via url: %s' % url )
    if exists_html(hash) is False:
        r = requests.get('https://via.hypothes.is/%s' % url, headers={'User-Agent':'Mozilla'})     
        log.info ( 'via result: %s' % r.status_code )
        text = r.text.replace('return;', '// return')               # work around https://github.com/hypothesis/via/issues/76
        text = text.replace ("""src="/im_""", 'src="https://via.hypothes.is')  # and that
        f = open('%s/%s.html' % (files_path, hash), 'wb')
        f.write(text.encode('utf-8'))
        f.close()
    export_url = '%s?uri=%s&user=__USER__' % (lti_export_url(settings), url)
    submit_html = ''
    if lis_result_sourcedid is not None:
        submit_html = render_submission_template(settings, oauth_consumer_key, lis_outcome_service_url, lis_result_sourcedid, url)
    html = render('lti:templates/html_assignment.html.jinja2', dict(
        name=name,
        submit_html=submit_html,
        hash=hash,
    ))
    r = Response(html.encode('utf-8'))
    r.content_type = 'text/html'
    return r

def lti_web(request, oauth_consumer_key=None, lis_outcome_service_url=None, lis_result_sourcedid=None, course=None, name=None, value=None):  # no api token needed in this case
    if oauth_consumer_key is None:
        oauth_consumer_key = get_post_or_query_param(request, OAUTH_CONSUMER_KEY)
    course = get_post_or_query_param(request, CUSTOM_CANVAS_COURSE_ID)
    user = get_post_or_query_param(request, CUSTOM_CANVAS_USER_ID)
    return web_response(request.registry.settings, oauth_consumer_key, course, lis_outcome_service_url, lis_result_sourcedid, name, value)

@view_config( route_name='lti_submit' )
def lti_submit(request, oauth_consumer_key=None, lis_outcome_service_url=None, lis_result_sourcedid=None, export_url=None):
    """
    Called from a student's view of an assignment.

    In theory can be an LTI launch but that's undocumented and did not seem to work. 
    So we use info we send to ourselves from the JS we generate on the assignment page.
    """
    log.info ( 'lti_submit: query: %s' % request.query_string )
    log.info ( 'lti_submit: post: %s' % request.POST )
    post_data = capture_post_data(request)  # unused until/unless this becomes an lti launch
    oauth_consumer_key = get_post_or_query_param(request, OAUTH_CONSUMER_KEY)
    lis_outcome_service_url = get_post_or_query_param(request, LIS_OUTCOME_SERVICE_URL)
    lis_result_sourcedid = get_post_or_query_param(request, LIS_RESULT_SOURCEDID)
    export_url = get_post_or_query_param(request, EXPORT_URL)

    try:
        secret = auth_data.get_lti_secret(oauth_consumer_key)   # because the submission must be OAuth1-signed
    except:
        return simple_response("We don't have the Consumer Key %s in our database yet." % oauth_consumer_key)

    oauth = OAuth1(client_key=oauth_consumer_key, client_secret=secret, signature_method='HMAC-SHA1', signature_type='auth_header', force_include_body=True)
    body = render('lti:templates/submission.xml.jinja2', dict(
        url=export_url,
        sourcedid=lis_result_sourcedid,
    ))
    headers = {'Content-Type': 'application/xml'}
    r = requests.post(url=lis_outcome_service_url, data=body, headers=headers, auth=oauth)
    log.info ( 'lti_submit: %s' % r.status_code )
    log.info ( 'lti_submit: %s' % r.text )
    response = None
    if ( r.status_code == 200 ):
        response = 'OK! Assignment successfully submitted.'
    else:
        response = 'Something is wrong. %s %s' % (r.status_code, r.text)        
    return simple_response(response)

@view_config( route_name='lti_export' )
def lti_export(request):
    """ 
    Called from Speed Grader, which presents the URL that the student submitted.

    Redirects to a variant of our viewer/export prototype which displays annotations for the
    assignment's PDF or URL, filtered to threads involving the (self-identified) H user, and
    highlighting contributions by that user.
    """
    args = get_query_param(request, 'args')  # because canvas swallows & in the submitted pox, we pass an opaque construct and unpack here
    log.info ( 'lti_export: query: %s' % request.query_string )
    parsed_args = urlparse.parse_qs(args)
    user = parsed_args['user'][0]
    uri = parsed_args['uri'][0]
    log.info( 'lti_export user: %s, uri %s' % ( user, uri) )
    export_url = '%s/export/facet.html?facet=uri&mode=documents&search=%s&user=%s' % ( lti_server(request.registry.settings), urllib.quote(uri), user )
    return HTTPFound(location=export_url)


def lti_credentials_form(settings):
    return """
<html>
<head> 

<style> 
body { font-family:verdana; margin:.5in; font-size:smaller } 
.path_ux { display:none; margin-top:1em; }
input { margin-top: 1em; }
</style> 

<script>
var endpoint = '__LTI_CREDENTIALS_URL__';

function getRVBN(rName) {
    var radioButtons = document.getElementsByName(rName);
    for (var i = 0; i < radioButtons.length; i++) {
        if (radioButtons[i].checked)
            return radioButtons[i];
    }
    return '';
}

function get_value(id) {
  return document.querySelector('#' + id).value;
}

function makeRequest (opts) {
//  alert('makeRequest: ' + opts.url);
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open(opts.method, opts.url);
    xhr.onload = function () {
      if (this.status >= 200 && this.status < 300) {
        resolve(xhr.response);
      } else {
        reject({
          status: this.status,
          statusText: xhr.statusText
        });
      }
    };
    xhr.onerror = function () {
      reject({
        status: this.status,
        statusText: xhr.statusText
      });
    };
    if (opts.headers) {
      Object.keys(opts.headers).forEach(function (key) {
        xhr.setRequestHeader(key, opts.headers[key]);
      });
    }
    var params = opts.params;
    if (params && typeof params === 'object') {
      params = Object.keys(params).map(function (key) {
        return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
      }).join('&');
    }
    xhr.send(params);
  });
}

function show() {
  document.querySelector('#results').innerHTML = '';
  var path = getRVBN('path_choice').value;
  console.log(path);
  if ( path == 'path_a' ) {
    document.getElementById('path_a_ux').style.display = 'block';
    document.getElementById('path_b_ux').style.display = 'none';
    document.getElementById('path_go').style.display = 'block';
    }
  if ( path =='path_b' ) {
    document.getElementById('path_a_ux').style.display = 'none';
    document.getElementById('path_b_ux').style.display = 'block';
    document.getElementById('path_go').style.display = 'block';
    }
  }

function go() {
  console.log('go');
  var path = getRVBN('path_choice').value;
  console.log('path');

  var json = '';

  if ( path == 'path_a' ) {
    json = { 
               "path_a_email"  : get_value('path_a_email'),
               "path_a_key"    : get_value('path_a_key'),
               "path_a_secret" : get_value('path_a_secret'),
               "path_a_host"   : get_value('path_a_host') 
               };
    }

  if ( path == 'path_b' ) {
    json = { 
               "path_b_email"        : get_value('path_b_email'),
               "path_b_firstname"    : get_value('path_b_firstname'),
               "path_b_lastname"     : get_value('path_b_lastname'),
               "path_b_token"        : get_value('path_b_token'),
               "path_b_host"         : get_value('path_b_host') 
               };
    }

  json = JSON.stringify(json);
  console.log(json);

  var options = {
    method: 'POST',
    url: endpoint + '?credentials=' + encodeURIComponent(json),
    headers: {"Content-type":"application/json" },
    params: json
    };

  makeRequest(options)
    .then ( function (data) {
      document.querySelector('#results').innerHTML = data;
    });

  }
</script>

</head>

<body>

<div>
I am sending credentials for:

<div>
<input onchange="javascript:show()" type="radio" name="path_choice" value="path_a"> <a target="_doc" title="read documentation for path A" href="https://docs.google.com/document/d/13FFtk2qRogtU3qxR_oa3kq2ak-S_p7HHVnNM12eZGy8/#heading=h.iigzwjedcwpf">Path A</a> (administrator-provided key and secret)
</div>

<div>
<input onchange="javascript:show()" type="radio" name="path_choice" value="path_b"> <a target="_doc" title="read documentation for path B" href="https://docs.google.com/document/d/13FFtk2qRogtU3qxR_oa3kq2ak-S_p7HHVnNM12eZGy8/#heading=h.9gwdor9wzz56">Path B</a> (teacher-provided token)
</div>

<div class="path_ux" id="path_a_ux">
<div><input id="path_a_email"></input> Email</div>
<div><input id="path_a_key"></input> Consumer Key</div>
<div><input id="path_a_secret"></input> Shared Secret</div>
<div><input id="path_a_host"></input> Canvas Server (example: canvas.myschool.edu) </div>
</div>

<div class="path_ux" id="path_b_ux">
<div><input id="path_b_firstname"></input> First Name</div>
<div><input id="path_b_lastname"></input> Last Name</div>
<div><input id="path_b_email"></input> Email</div>
<div><input id="path_b_token"></input> Canvas Token</div>
<div><input id="path_b_host"></input> Canvas Server (example: canvas.myschool.edu)</div>
</div>

<div class="path_ux" id="path_go">
<input type="button" value="go" onclick="javascript:go()"></input>
</div>

</div>

<div id="results"></div>

</body>
</html>
    """.replace('__LTI_CREDENTIALS_URL__', settings['lti_credentials_url'])

def cors_response(request, response=None):
    if response is None:
        response = Response()
    request_headers = request.headers['Access-Control-Request-Headers'].lower()
    request_headers = re.findall('\w(?:[-\w]*\w)', request_headers)
    response_headers = ['access-control-allow-origin']
    for req_acoa_header in request_headers:
        if req_acoa_header not in response_headers:
            response_headers.append(req_acoa_header)
    response_headers = ','.join(response_headers)
    response.headers.update({
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': '%s' % response_headers,
        'Access-Control-Allow-Methods': "UPDATE, POST, GET"
        })
    response.status_int = 204
    print ( response.headers )
    return response

@view_config( route_name='lti_credentials' )
def lti_credentials(request):
    """ 
    Receive credentials for path A (key/secret/host) or path B (username.username/token/host)
    """
    if  request.method == 'OPTIONS':
        return cors_response(request)
    else:
        credentials = get_query_param(request, 'credentials')
        if ( credentials is None ):
          return page_response(lti_credentials_form(request.registry.settings))
        else: 
          lock = filelock.FileLock("credentials.lock")
          with lock.acquire(timeout = 1):
            with open('credentials.txt', 'a') as f:
              f.write(credentials + '\n')
          return bare_response("<p>Thanks!</p><p>We received:</p><p>%s</p><p>We'll contact you to explain next steps.</p>" % credentials)


@view_config( route_name='lti_serve_pdf' )
def lti_serve_pdf(request):
    if request.referer is not None and 'pdf.worker.js' in request.referer:
        return serve_file(path=files_path,
                      file=request.matchdict['file'] + '.pdf',
                      request=request,
                      content_type='application/pdf')
    else:
        return simple_response('You are not logged in to Canvas')

from wsgiref.simple_server import make_server
from pyramid.config import Configurator
from pyramid.response import Response
from pyramid.static import static_view

def app():
    config = configure()

    config.include('pyramid_jinja2')

    config.scan()

    config.add_route('token_callback',      '/token_callback')
    config.add_route('refresh_callback',    '/refresh_callback')
    config.add_route('lti_setup',           '/lti_setup')
    config.add_route('lti_submit',          '/lti_submit')
    config.add_route('lti_export',          '/lti_export')
    config.add_route('lti_credentials',     '/lti_credentials')
    config.add_route('config_xml',          '/config')  # FIXME: This should be /config.xml as in Canvas's examples.
    config.add_route('about',               '/')

    config.add_route('lti_serve_pdf',       '/viewer/web/{file}.pdf')

    pdf_view = static_view('lti:static/pdfjs')
    config.add_route('catchall_pdf', '/viewer/*subpath')
    config.add_view(pdf_view, route_name='catchall_pdf')


    config.add_static_view(name='export', path='lti:static/export')

    return config.make_wsgi_app()
